---
title: Gatan .dm3 & .dm4 file formats
tags: 
- Digital Micrograph
---

<style>
pre {
	tab-size: 4;
	-moz-tab-size: 4;
}
code {
	max-height: 20rem;
}
</style>

# **Image Data Types**

## All possible **Image Date Types**

**Image Data Type** is a series of encoded numbers for *.dm2/3/4* files to determine the carried **Images**' types. **Image Data Type** is stored at **Tag** `ImageData:DataType` of every **Image** (including the thumbnail) which is under **TagList** `ImageList`. The below *DM* script illustrates all possible **Image Data Type** numbers:

<div class="clearfix" markdown="1">
<div markdown="1" class="left-half">

``` c++ 
number i,n1,n2
string s1,s2
result("\nimage_data_type  data_class  scalar_class  variant  scalar_bit_size\n")
for(i=0;i<100;i++)
	if (ImageDeconstructDataType(i,s1,s2,n1,n2))
		result(i+"\t\t"+s1+"\t\t"+s2+"\t\t"+n1+"\t "+n2+"\n")
```
</div>

<div markdown="1" class="dataTable right-half">
image_data_type | data_class | scalar_class | variant | scalar_bit_size
|---|
1 | scalar | sint | 0 |  16
2 | scalar | float | 0 |  32
3 | complex | float | 0 |  32
5 | complex | float | 0 |  32
6 | scalar | uint | 0 |  8
7 | scalar | sint | 0 |  32
8 | rgba | uint | 3 |  8
9 | scalar | sint | 0 |  8
10 | scalar | uint | 0 |  16
11 | scalar | uint | 0 |  32
12 | scalar | float | 0 |  64
13 | complex | float | 0 |  64
14 | scalar | binary | 0 |  8
15 | rgb | uint | 0 |  8
16 | rgb | uint | 1 |  8
17 | rgb | uint | 0 |  16
18 | rgb | float | 0 |  32
19 | rgb | float | 0 |  64
20 | rgba | uint | 0 |  8
21 | rgba | uint | 1 |  8
22 | rgba | uint | 2 |  8
23 | rgba | uint | 3 |  8
24 | rgba | uint | 0 |  16
25 | rgba | float | 0 |  32
26 | rgba | float | 0 |  64
27 | complex | float | 0 |  32
28 | complex | float | 0 |  64
29 | point2 | sint | 0 |  16
30 | point2 | sint | 1 |  16
31 | point2 | sint | 0 |  64
32 | point2 | float | 0 |  32
33 | point2 | float | 0 |  64
34 | rect | sint | 1 |  16
35 | rect | sint | 1 |  64
36 | rect | float | 1 |  32
37 | rect | float | 0 |  32
38 | rect | float | 0 |  64
39 | scalar | sint | 0 |  64
40 | scalar | uint | 0 |  64

</div>

This list should include all possible values in `ImageData:DataType`. Meanings of the headers/specifications are:
1. `image_data_type`: **Image Data Type**;
1. `data_class`: what pixels in the **Image** are composed of, 
 - `scalar` - a single number,
 - `complex`/`point2` - 2 numbers per pixel,
 - `rgb` - 3 numbers per pixel,
 - `rgba`/`rect` - 4 numbers per pixel;
1. `scalar_class`: type (class) of the individual numbers in the pixels (`sint` is **Signed Integer**);
1. `variant`: differentiates similar **Image Data Types** while other specifications are identical, according to *DM*'s F1 Help Manual;
1. `scalar_bit_size`: the **Bit Size** of the individual numbers.

For **RGB(A) Images**, I can image there could be `RGB`/`BGA` ordering **variants**. *DM F1* says that, **Type 23** `RBGImage("",4,1,18)` is mapping each **RGBA** pixel to a 4-byte chunk, which is a common practice. *DM F1* also says that currently the **alpha** channel is not really being used. **Type 5** **Complex Image** is known [^1] as the **Packed Complex** type, which should have about half of the size of a regular **Complex Image**. It seems certain similar **Image Data Types** have identical **variant** as well as other specifications. Also **Type 4** is indeed non-existent. 

</div>

## Usual **Image Data Types**

Practically speaking, we may only care for **Image Data Types** that are generated by "common" *DM* usages, which are demonstrated below: 

<div class="clearfix" markdown="1">
<div class="left-half" markdown="1">

``` c++
ImageDocument imgdoc = CreateImageDocument( "New ImageDocument" ) 
// Showing the ImageDocument makes the first added image's name 
//   not being overwritten by that of the last added image
imgDoc.ImageDocumentShow() 

number y=1
imgdoc.ImageDocumentAddImage(BinaryImage("BinaryImage(\"\",1,"+y+")",1,y++))
imgdoc.ImageDocumentAddImage(ComplexImage("ComplexImage(\"\",16,1,"+y+")",16,1,y++))
imgdoc.ImageDocumentAddImage(ComplexImage("ComplexImage(\"\",8,1,"+y+")",8,1,y++))
imgdoc.ImageDocumentAddImage(RealFFT(RealImage("RealImage(\"\",4,4,4)",4,4,4)))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",1,0,1,"+y+")",1,0,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",1,1,1,"+y+")",1,1,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",2,0,1,"+y+")",2,0,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",2,1,1,"+y+")",2,1,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",4,0,1,"+y+")",4,0,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",4,1,1,"+y+")",4,1,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",8,0,1,"+y+")",8,0,1,y++))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",8,1,1,"+y+")",8,1,1,y++))
image r4 := RealImage("RealImage(\"\",4,4,4);ConvertToPackedComplex",4,4,4)
ConvertToPackedComplex(r4)
imgdoc.ImageDocumentAddImage(r4)
imgdoc.ImageDocumentAddImage(RealImage("RealImage(\"\",4,1,"+y+")",4,1,y++))
image r8 := RealImage("RealImage(\"\",8,4,4);ConvertToPackedComplex",8,4,4)
ConvertToPackedComplex(r8)
imgdoc.ImageDocumentAddImage(r8)
imgdoc.ImageDocumentAddImage(RealImage("RealImage(\"\",8,1,"+y+")",8,1,y++))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",3,1,"+y+")",3,1,y++))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",4,1,"+y+")",4,1,y++))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",6,1,"+y+")",6,1,y++))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",8,1,"+y+")",8,1,y++))

result("\n")
number i,n1,n2
string s1,s2

result("Type\tPixel\tNumeric\tVariant\tBit\tImage Name\n")
for(i=0;i<imgdoc.ImageDocumentCountImages();i++) {
	image ii := imgdoc.ImageDocumentGetImage(i)
	number t = ii.ImageGetDataType()
	ImageDeconstructDataType(t,s1,s2,n1,n2)
	result(t+"\t"+s1+"\t"+s2+"\t"+n1+"\t"+n2+"\t"+ii.ImageGetName()+"\n")
}

string path
if(SaveAsDialog("Save the testing multi-images document as .dm4", GetApplicationDirectory("open_save",0), path ))
	imgdoc.ImageDocumentSaveToFile("Gatan Format",path)
```
</div>

<div markdown="1" class="dataTable ttmd right-half">
Type | Pixel | Numeric | Variant | Bit | Image Name
|-|
14 | scalar | binary | 0 | 8 | BinaryImage("",1,1)
13 | complex | float | 0 | 64 | ComplexImage("",16,1,2)
3 | complex | float | 0 | 32 | ComplexImage("",8,1,3)
3 | complex | float | 0 | 32 | FFT of RealImage("",4,4,4)
6 | scalar | uint | 0 | 8 | IntegerImage("",1,0,1,4)
9 | scalar | sint | 0 | 8 | IntegerImage("",1,1,1,5)
10 | scalar | uint | 0 | 16 | IntegerImage("",2,0,1,6)
1 | scalar | sint | 0 | 16 | IntegerImage("",2,1,1,7)
11 | scalar | uint | 0 | 32 | IntegerImage("",4,0,1,8)
7 | scalar | sint | 0 | 32 | IntegerImage("",4,1,1,9)
40 | scalar | uint | 0 | 64 | IntegerImage("",8,0,1,10)
39 | scalar | sint | 0 | 64 | IntegerImage("",8,1,1,11)
3 | complex | float | 0 | 32 | RealImage("",4,4,4);ConvertToPackedComplex
2 | scalar | float | 0 | 32 | RealImage("",4,1,12)
13 | complex | float | 0 | 64 | RealImage("",8,4,4);ConvertToPackedComplex
12 | scalar | float | 0 | 64 | RealImage("",8,1,13)
15 | rgb | uint | 0 | 8 | RGBImage("",3,1,14)
23 | rgba | uint | 3 | 8 | RGBImage("",4,1,15)
17 | rgb | uint | 0 | 16 | RGBImage("",6,1,16)
24 | rgba | uint | 0 | 16 | RGBImage("",8,1,17)

</div>

This script will create and ask to save a multi-**Image** `ImageDocument`. Please note that: 
1. Arithmetical operations may automatically convert some other **Image Data Types** images into **Real Images**, and
2. **64-bit Integer Images** are not quite supported by the current *DM* and often cause warnings.

Because this list is being reported before saving the **Image Document**, there will be no thumbnail yet. Upon saving, a thumbnail will be generated (and named `Image Of RGBImage("",8,1,17)` in this case).

**Packed Complex Images** seem to be uncapturable here, as *DM F1* says "... this data type can't be used with image expressions ...".

</div>

# Tag/Scalar Data Types

<div class="clearfix" markdown="1">
<div class="left-half" markdown="1">

``` c++
taggroup tg=newtaggroup()
result("\n")

number y=1
tg.TagGroupSetTagAsArray("Array=BinaryImage(\"\",1,"+y+")",BinaryImage("",1,y++))
tg.TagGroupSetTagAsArray("Array=ComplexImage(\"\",16,1,"+y+")",ComplexImage("",16,1,y++))
tg.TagGroupSetTagAsArray("Array=ComplexImage(\"\",8,1,"+y+")",ComplexImage("",8,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",1,0,1,"+y+")",IntegerImage("",1,0,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",1,1,1,"+y+")",IntegerImage("",1,1,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",2,0,1,"+y+")",IntegerImage("",2,0,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",2,1,1,"+y+")",IntegerImage("",2,1,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",4,0,1,"+y+")",IntegerImage("",4,0,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",4,1,1,"+y+")",IntegerImage("",4,1,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",8,0,1,"+y+")",IntegerImage("",8,0,1,y++))
tg.TagGroupSetTagAsArray("Array=IntegerImage(\"\",8,1,1,"+y+")",IntegerImage("",8,1,1,y++))
tg.TagGroupSetTagAsArray("Array=RealImage(\"\",4,1,"+y+")",RealImage("",4,1,y++))
tg.TagGroupSetTagAsArray("Array=RealImage(\"\",8,1,"+y+")",RealImage("",8,1,y++))
tg.TagGroupSetTagAsArray("Array=RGBImage(\"\",3,1,"+y+")",RGBImage("",3,1,y++))
tg.TagGroupSetTagAsArray("Array=RGBImage(\"\",4,1,"+y+")",RGBImage("",4,1,y++))
tg.TagGroupSetTagAsArray("Array=RGBImage(\"\",6,1,"+y+")",RGBImage("",6,1,y++))
tg.TagGroupSetTagAsArray("Array=RGBImage(\"\",8,1,"+y+")",RGBImage("",8,1,y++))
tg.TagGroupSetTagAsBoolean("Boolean=1",1)
tg.TagGroupSetTagAsDouble("Double=23456789012345678901",23456789012345678901)
tg.TagGroupSetTagAsDoubleComplex("DoubleComplex=complex(23456789012345678901,34567890123456789012)",complex(23456789012345678901,34567890123456789012))
tg.TagGroupSetTagAsEightBitColor("EightBitColor=rgba(255,254,253,252)",rgba(255,254,253,252))
tg.TagGroupSetTagAsFloat("Float=23456789012345678901",23456789012345678901)
tg.TagGroupSetTagAsLong("Long=-2147483647",-2147483647)
tg.TagGroupSetTagAsNumber("Number=rgba(255,254,253,252)",rgba(255,254,253,252))
tg.TagGroupSetTagAsNumber("Number=complex(23456789012345678901,34567890123456789012)",complex(23456789012345678901,34567890123456789012))
tg.TagGroupSetTagAsNumber("Number=23456789012345678901",23456789012345678901)
tg.TagGroupSetTagAsNumber("Number=0",0)
tg.TagGroupSetTagAsRGBUInt16("RGBUInt16=65535,65534,65533",65535,65534,65533)
tg.TagGroupSetTagAsShort("Short=-32768",-32768)
tg.TagGroupSetTagAsShortPoint("ShortPoint=-32768,32768",-32768,32768)
tg.TagGroupSetTagAsShortRect("ShortRect=-32768,32768,-32767,32767",-32768,32768,-32767,32767)
tg.TagGroupSetTagAsSInt64("SInt64=-9223372036854775807",-9223372036854775807)
tg.TagGroupSetTagAsString("String=\"S\"","S")
tg.TagGroupSetTagAsTagGroup("TagGroup=newtaggroup()",newtaggroup())
tg.TagGroupSetTagAsText("Text=\"T\"","T")
tg.TagGroupSetTagAsUInt16("UInt16=65535",65535)
tg.TagGroupSetTagAsUInt32("UInt32=4294967295",4294967295)
tg.TagGroupSetTagAsUInt64("UInt64=18446744073709551615",18446744073709551615)
tg.TagGroupSetTagRGBBitmap("RGBBitmap=RGBImage(\"\",3,1,14)",RGBImage("",3,1,14))

tg.taggroupopenbrowserwindow(1)

result("0\t1\t2\t3\t4\t5\t6\t7\t8\t9\tA\tB\tC\tTag Label\tTagGroupGetTagAs___()\n")
number i,j,c
for(i=0;i<tg.taggroupcounttags();i++){
	c=tg.TagGroupGetTagTypeLength(i)
	for(j=0;j<c;j++)
		result(tg.taggroupgettagtype(i,j)+"\t")
	for(j=0;j<13-c;j++)
		result("\t")
	string l=tg.taggroupgettaglabel(i)
	result(l+"\t")
	
	number n0=0,n1=0,n2=0,n3=0
	complexnumber nc=0
	rgbnumber nr=0
	string s=""
	taggroup t
	
	if (l=="Boolean=1") {tg.taggroupgettagasboolean(l,n0); result(format(n0,"%.20g"));}
	if (l=="Double=23456789012345678901") {tg.TagGroupGetTagAsDouble(l,n0); result(format(n0,"%.20g"));}
	if (l=="DoubleComplex=complex(23456789012345678901,34567890123456789012)") {tg.TagGroupGetTagAsDoubleComplex(l,nc); result(format(real(nc),"%.20g,")+format(imaginary(nc),"%.20g"));}
	if (l=="EightBitColor=rgba(255,254,253,252)") {tg.TagGroupGetTagAsEightBitColor(l,nr); result(nr);}
	if (l=="Float=23456789012345678901") {tg.TagGroupGetTagAsfloat(l,n0); result(format(n0,"%.20g"));}
	if (l=="Long=-2147483647") {tg.TagGroupGetTagAslong(l,n0); result(format(n0,"%.20g"));}
	if (l=="Number=rgba(255,254,253,252)") {tg.TagGroupGetTagAsnumber(l,nr); result(nr);}
	if (l=="Number=complex(23456789012345678901,34567890123456789012)") {tg.TagGroupGetTagAsnumber(l,nc); result(format(real(nc),"%.20g,")+format(imaginary(nc),"%.20g"));}
	if (l=="Number=23456789012345678901") {tg.TagGroupGetTagAsnumber(l,n0); result(format(n0,"%.20g"));}
	if (l=="Number=0") {tg.TagGroupGetTagAsnumber(l,n0); result(format(n0,"%.20g"));}
	if (l=="RGBUInt16=65535,65534,65533") {tg.TagGroupGetTagAsRGBUInt16(l,n0,n1,n2); result(n0+","+n1+","+n2);}
	if (l=="Short=-32768") {tg.TagGroupGetTagAsshort(l,n0); result(format(n0,"%.20g"));}
	if (l=="ShortPoint=-32768,32768") {tg.TagGroupGetTagAsshortpoint(l,n0,n1); result(n0+","+n1);}
	if (l=="ShortRect=-32768,32768,-32767,32767") {tg.TagGroupGetTagAsshortrect(l,n0,n1,n2,n3); result(n0+","+n1+","+n2+","+n3);}
	if (l=="SInt64=-9223372036854775807") {tg.TagGroupGetTagAssint64(l,n0); result(format(n0,"%.20g"));}
	if (l=="String=\"S\"") {tg.TagGroupGetTagAsstring(l,s); result(s);}
	if (l=="Text=\"T\"") {tg.TagGroupGetTagAstext(l,s); result(s);}
	if (l=="UInt16=65535") {tg.TagGroupGetTagAsuint16(l,n0); result(format(n0,"%.20g"));}
	if (l=="UInt32=4294967295") {tg.TagGroupGetTagAsuint32(l,n0); result(format(n0,"%.20g"));}
	if (l=="UInt64=18446744073709551615") {tg.TagGroupGetTagAsuint64(l,n0); result(format(n0,"%.20g"));}
	
	result("\n")
}
```
</div>
<div markdown="1" class="dataTable ttmd right-half">
0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | Tag Label | TagGroupGetTagAs___()
---|---|
\b/20\/ | \r/8\/ | \b/*1*\/ |  |  |  |  |  |  |  |  |  |  | Array=BinaryImage("",1,1) | 
\b/20\/ | \g/15\/ | 0 | \g/*2*\/ | 0 | \r/7\/ | 0 | \r/7\/ | \b/*2*\/ |  |  |  |  | Array=ComplexImage("",16,1,2) | 
\b/20\/ | \g/15\/ | 0 | \g/*2*\/ | 0 | \r/6\/ | 0 | \r/6\/ | \b/*3*\/ |  |  |  |  | Array=ComplexImage("",8,1,3) | 
\b/20\/ | \r/10\/ | \b/*4*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",1,0,1,4) | 
\b/20\/ | \r/9\/ | \b/*5*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",1,1,1,5) | 
\b/20\/ | \r/4\/ | \b/*6*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",2,0,1,6) | 
\b/20\/ | \r/2\/ | \b/*7*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",2,1,1,7) | 
\b/20\/ | \r/5\/ | \b/*8*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",4,0,1,8) | 
\b/20\/ | \r/3\/ | \b/*9*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",4,1,1,9) | 
\b/20\/ | \r/12\/ | \b/*10*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",8,0,1,10) | 
\b/20\/ | \r/11\/ | \b/*11*\/ |  |  |  |  |  |  |  |  |  |  | Array=IntegerImage("",8,1,1,11) | 
\b/20\/ | \r/6\/ | \b/*12*\/ |  |  |  |  |  |  |  |  |  |  | Array=RealImage("",4,1,12) | 
\b/20\/ | \r/7\/ | \b/*13*\/ |  |  |  |  |  |  |  |  |  |  | Array=RealImage("",8,1,13) | 
\b/20\/ | \g/15\/ | 3 | \g/*3*\/ | 0 | \r/10\/ | 1 | \r/10\/ | 2 | \r/10\/ | \b/*14*\/ |  |  | Array=RGBImage("",3,1,14) | 
\b/20\/ | \r/3\/ | \b/*15*\/ |  |  |  |  |  |  |  |  |  |  | Array=RGBImage("",4,1,15) | 
\b/20\/ | \g/15\/ | 3 | \g/*3*\/ | 0 | \r/4\/ | 1 | \r/4\/ | 2 | \r/4\/ | \b/*16*\/ |  |  | Array=RGBImage("",6,1,16) | 
\b/20\/ | \g/15\/ | 4 | \g/*4*\/ | 0 | \r/4\/ | 1 | \r/4\/ | 2 | \r/4\/ | 3 | \r/4\/ | \b/*17*\/ | Array=RGBImage("",8,1,17) | 
\r/8\/ |  |  |  |  |  |  |  |  |  |  |  |  | Boolean=1 | 1
\r/7\/ |  |  |  |  |  |  |  |  |  |  |  |  | Double=234567890123456~~78901~~ | 234567890123456~~79872~~
\g/15\/ | 0 | \g/*2*\/ | 0 | \r/7\/ | 0 | \r/7\/ |  |  |  |  |  |  | DoubleComplex=complex(234567890123456~~78901~~,345678901234567~~89012~~) | 234567890123456~~79872~~,345678901234567~~90528~~
\r/3\/ |  |  |  |  |  |  |  |  |  |  |  |  | EightBitColor=rgba(255,254,253,252) | 255,254,253,252
\r/6\/ |  |  |  |  |  |  |  |  |  |  |  |  | Float=23456789~~012345678901~~ | 23456789~~751949950976~~
\r/3\/ |  |  |  |  |  |  |  |  |  |  |  |  | Long=-2147483647 | -2147483647
\r/7\/ |  |  |  |  |  |  |  |  |  |  |  |  | Number=0 | 0
\r/7\/ |  |  |  |  |  |  |  |  |  |  |  |  | Number=234567890123456~~78901~~ | 234567890123456~~79872~~
\g/15\/ | 0 | \g/*2*\/ | 0 | \r/7\/ | 0 | \r/7\/ |  |  |  |  |  |  | Number=complex(234567890123456~~78901~~,345678901234567~~89012~~) | 234567890123456~~79872~~,345678901234567~~90528~~
\r/3\/ |  |  |  |  |  |  |  |  |  |  |  |  | Number=rgba(255,254,253,252) | 255,254,253,252
\b/20\/ | \r/3\/ | \b/*14*\/ |  |  |  |  |  |  |  |  |  |  | RGBBitmap=RGBImage("",3,1,14) | 
\g/15\/ | 0 | \g/*3*\/ | 0 | \r/2\/ | 0 | \r/2\/ | 0 | \r/2\/ |  |  |  |  | RGBUInt16=65535,65534,65533 | 65535,65534,65533
\r/2\/ |  |  |  |  |  |  |  |  |  |  |  |  | Short=-32768 | -32768
\g/15\/ | 0 | \g/*2*\/ | 0 | \r/2\/ | 0 | \r/2\/ |  |  |  |  |  |  | ShortPoint=-32768,\Y/32768\/ | -32768,\Y/32767\/
\g/15\/ | 0 | \g/*4*\/ | 0 | \r/2\/ | 0 | \r/2\/ | 0 | \r/2\/ | 0 | \r/2\/ |  |  | ShortRect=-32768,\Y/32768\/,-32767,32767 | -32768,\Y/32767\/,-32767,32767
\r/11\/ |  |  |  |  |  |  |  |  |  |  |  |  | SInt64=-92233720368547~~75807~~ | -92233720368547~~75808~~
\b/20\/ | \r/4\/ | \b/*1*\/ |  |  |  |  |  |  |  |  |  |  | String="S" | S
 |  |  |  |  |  |  |  |  |  |  |  |  | TagGroup=newtaggroup() | 
\b/20\/ | \r/4\/ | \b/*1*\/ |  |  |  |  |  |  |  |  |  |  | Text="T" | T
\r/4\/ |  |  |  |  |  |  |  |  |  |  |  |  | UInt16=65535 | 65535
\r/5\/ |  |  |  |  |  |  |  |  |  |  |  |  | UInt32=4294967295 | 4294967295
\r/12\/ |  |  |  |  |  |  |  |  |  |  |  |  | UInt64=~~18446744073709551615~~ | ~~9223372036854775808~~

</div>
</div>

# *GMS* Versions
Tested *GMS* versions:
1. *GMS 1.4.3* (*DM Demo 3.9.3*). File saving is not supported as a Demo.
1. *GMS 2.0.1* (2.01.697.0).
1. *GMS 3.4.2* (3.42.3048.0).

The output of these tested versions are mostly the same, except for:
- Only this *GMS 3* support `TagGroupSetTagAsSInt64()`/`TagGroupSetTagAsUInt64()`, although these *GMS 1* & *2* both support **8-byte Integer Images** as well. 
- This *GMS 1* also has trouble with `TagGroupSetTagAsArray()` combined with **8-byte Integer Images**. 
- The **Image Data Types 27/28 Complex 32-/64-bit** do not exist on this *GMS 1*. This leads to the next two differences.
- On this *GMS 1*, the **64-bit scalar signed/unsigned integer Image Data Types** are numbered as **37/38**, while as **39/40** on these *GMS 2* & *GMS 3*, respectively.
- On this *GMS 1*, `RealImage("",8,4,4)` then `ConvertToPackedComplex()` results a **Type 3 Complex Image**. Maybe **Image Data Types 27/28 Complex** are related to the **Packed Complex**.
- On this *GMS 3*, the `result()` of the list of images in a `ImageDocument` is in reverse order, while the `ImageList` `TagGroup` in the saved file is identical to that of those other two versions.

No other **Image/Tag/Scalar Data Type** difference was found. There are also some patterns regarding **String**/**Text** **Tags** in *.dm3/4* files:

- The **Tag/Scalar Type 18** known as **String** cannot be found/created in any *.dm3/4* image files (using a self-written script outside *DM* to read the whole binary files) generated throughout these tests. Maybe it no long exists in *.dm3/4*.
- The same also appiles to **Tag/Scalar Type 9** known as **int8**/**char**. No instance of **char** usage was found/created; only **int8**.
- All **String**/**Text** **Tags** are stored as **uint16 Arrays**. 
- *DM* seems to always interpret **int8**/**uint16 Array Tags** as **Text** (in `TagGroupOpenBrowserWindow()`).
- Except for `ImageData:Data` **int8**/**unint16 Array Tags** in the `ImageList`, which are absolutely **Images**.
- **RGB Images**, like `CLUT`, which are not in the `ImageList` and supposed to have **uint16 scalars**, are marked with **int16 scalars** instead. Maybe it is to distinguish any **Image** from **Text** in **Tags**. They will be extracted as **uint16** by *DM* according to their **Tag Paths**, I guess.

The scripts/outputs demonstrated here are for/from *GMS 3.4.2*.

# Other sources of *\.dm3/4* information
There are quite a few other sources worth a read [^1]  [^2]  [^3]  [^4].

[^1]: [*Digital Micrograph file format*](http://phyweb.physics.nus.edu.sg/~phybcb/info/dmformat/index.html), by Dr Chris Boothroyd. A must-read. I learned the structure of *.dm3/4* files from here.
[^2]: [`EMAN::DM4IO` Class Reference](https://blake.grid.bcm.edu/eman2/doxygen_html/classEMAN_1_1DM4IO.html), *.dm4* I/O for *EMAN2*, written in C++.
[^3]: [`DM3_Reader` plugin](https://imagej.nih.gov/ij/plugins/DM3_Reader.html) for *ImageJ*.
[^4]: [`ncempy.io.dm`](https://openncem.readthedocs.io/en/latest/ncempy.io.html#module-ncempy.io.dm), the *.dm3/4* I/O module of *openNCEM*'s python package.

