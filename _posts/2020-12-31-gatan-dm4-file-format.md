---
title: Gatan DM4 file format
tags: 
- Digital Micrograph
---

<style type="text/css">
pre {
    tab-size: 8;
}
table.dataTable td {
  padding: 0;
}
</style>

Digital Micrograph version: 3.42.3048.0.

# **Image Data Types**

## All possible **Image Date Types**

**Image Data Type** is a series of encoded numbers for *DM2/3/4* files to determine the carried **Image**'s type. **Image Data Type** is stored at **Tag** `ImageData:DataType` under every **Image** (including the thumbnail) under **Lv. 1** **TagList** `ImageList`. The below *DM* script illustrates all possible **Image Data Type** numbers:

``` c
number i,n1,n2
string s1,s2
result("\nimage_data_type  data_class  scalar_class  variant  scalar_bit_size\n")
for(i=0;i<100;i++)
	if (ImageDeconstructDataType(i,s1,s2,n1,n2))
		result(i+"\t\t"+s1+"\t\t"+s2+"\t\t"+n1+"\t "+n2+"\n")
```

This outputs the following list, which should include all possible values in `ImageData:DataType`. Meanings of the headers/specifications are:
1. `image_data_type`: **Image Data Type**;
1. `data_class`: what pixels in the **Image** are composed of, 
 - `scalar` - a single number,
 - `complex`/`point2` - 2 numbers per pixel,
 - `rgb` - 3 numbers per pixel,
 - `rgba`/`rect` - 4 numbers per pixel;
1. `scalar_class`: type (class) of the individual numbers in the pixels (`sint` is **Signed Integer**);
1. `variant`: differentiates similar **Image Data Types** while other specifications are identical, according to *DM*'s F1 Help Manual;
1. `scalar_bit_size`: the **Bit Size** of the individual numbers.

<div class="datatable-begin"></div>

image_data_type | data_class | scalar_class | variant | scalar_bit_size
---|---|---|---|---|
1 | scalar | sint | 0 |  16
2 | scalar | float | 0 |  32
3 | complex | float | 0 |  32
5 | complex | float | 0 |  32
6 | scalar | uint | 0 |  8
7 | scalar | sint | 0 |  32
8 | rgba | uint | 3 |  8
9 | scalar | sint | 0 |  8
10 | scalar | uint | 0 |  16
11 | scalar | uint | 0 |  32
12 | scalar | float | 0 |  64
13 | complex | float | 0 |  64
14 | scalar | binary | 0 |  8
15 | rgb | uint | 0 |  8
16 | rgb | uint | 1 |  8
17 | rgb | uint | 0 |  16
18 | rgb | float | 0 |  32
19 | rgb | float | 0 |  64
20 | rgba | uint | 0 |  8
21 | rgba | uint | 1 |  8
22 | rgba | uint | 2 |  8
23 | rgba | uint | 3 |  8
24 | rgba | uint | 0 |  16
25 | rgba | float | 0 |  32
26 | rgba | float | 0 |  64
27 | complex | float | 0 |  32
28 | complex | float | 0 |  64
29 | point2 | sint | 0 |  16
30 | point2 | sint | 1 |  16
31 | point2 | sint | 0 |  64
32 | point2 | float | 0 |  32
33 | point2 | float | 0 |  64
34 | rect | sint | 1 |  16
35 | rect | sint | 1 |  64
36 | rect | float | 1 |  32
37 | rect | float | 0 |  32
38 | rect | float | 0 |  64
39 | scalar | sint | 0 |  64
40 | scalar | uint | 0 |  64

<div class="datatable-end"></div>

For **RGB(A) Images**, I can image there could be `RGB`/`BGA` ordering **variants**. **Type 5** **Complex Image** is recorded [[1]] as a **Packed Complex** type, which should have about half the size of a regular **Complex Image**, for using symmetric "dummy" expressions for FFT results of **Real Images**. It seems certain similar **Image Data Types** have identical **variant** as well as other specifications. Also **Type 4** is indeed non-existent. 

## Usual **Image Data Types**

Practically speaking, we may only care for **Image Data Types** that are generated by common *DM* usages. Common **Image Data Types** that can be created via *DM* image creation functions are demonstrated below: 

``` c
ImageDocument imgdoc = CreateImageDocument( "New ImageDocument" ) 
// Showing the ImageDocument makes the first added image's name 
//   not being overwritten by that of the last added image
imgDoc.ImageDocumentShow() 

image r4 := RealImage("RealImage(\"\",4,1,1);ConvertToPackedComplex",4,1,1)
image r8 := RealImage("RealImage(\"\",8,1,2);ConvertToPackedComplex",8,1,2)
ConvertToPackedComplex(r4)
ConvertToPackedComplex(r8)
imgdoc.ImageDocumentAddImage(r4)
imgdoc.ImageDocumentAddImage(r8)
imgdoc.ImageDocumentAddImage(BinaryImage("BinaryImage(\"\",1,3)",1,3))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",1,0,1,4)",1,0,1,4))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",1,1,1,5)",1,1,1,5))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",4,0,1,6)",4,0,1,6))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",4,1,1,7)",4,1,1,7))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",8,0,1,8)",8,0,1,8))
imgdoc.ImageDocumentAddImage(IntegerImage("IntegerImage(\"\",8,1,1,9)",8,1,1,9))
imgdoc.ImageDocumentAddImage(RealFFT(RealImage("RealImage(\"\",4,1,10)",4,1,10)))
imgdoc.ImageDocumentAddImage(RealImage("RealImage(\"\",4,1,10)",4,1,10))
imgdoc.ImageDocumentAddImage(RealImage("RealImage(\"\",8,1,11)",8,1,11))
imgdoc.ImageDocumentAddImage(ComplexImage("ComplexImage(\"\",8,1,12)",8,1,12))
imgdoc.ImageDocumentAddImage(ComplexImage("ComplexImage(\"\",16,1,13)",16,1,13))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",3,1,14)",3,1,14))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",4,1,15)",4,1,15))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",6,1,16)",6,1,16))
imgdoc.ImageDocumentAddImage(RGBImage("RGBImage(\"\",8,1,17)",8,1,17))

result("\n")
number i,n1,n2
string s1,s2

result("#\tType\tPixel\tNumeric\tVariant\tBit\tImage Name\n")
for(i=0;i<imgdoc.ImageDocumentCountImages();i++) {
	image ii := imgdoc.ImageDocumentGetImage(i)
	number t = ii.ImageGetDataType()
	ImageDeconstructDataType(t,s1,s2,n1,n2)
	result(i+"\t"+t+"\t"+s1+"\t"+s2+"\t"+n1+"\t"+n2+"\t"+ii.ImageGetName()+"\n")
}

string path
if(SaveAsDialog("Save the testing multi-images document as .dm4", GetApplicationDirectory("open_save",0), path ))
	imgdoc.ImageDocumentSaveToFile("Gatan Format",path)
```

This script will create and ask to save a multi-**Image** `ImageDocument`. Please note that: 
1. Arithmetical operations may automatically convert some other **Image Data Types** images into **Real Images**, and
2. **64-bit Integer Images** are not quite supported by the current *DM* and often cause warnings.

The **Image Data Type** information reported by *DM* will be:

<div class="datatable-begin"></div>

#| Type | Pixel | Numeric | Variant | Bit | Image Name
---|---|---|---|---|---|---
0 | 3 | complex | float | 0 | 32 | RealImage("",4,1,1);ConvertToPackedComplex
1 | 13 | complex | float | 0 | 64 | RealImage("",8,1,2);ConvertToPackedComplex
2 | 14 | scalar | binary | 0 | 8 | BinaryImage("",1,3)
3 | 6 | scalar | uint | 0 | 8 | IntegerImage("",1,0,1,4)
4 | 9 | scalar | sint | 0 | 8 | IntegerImage("",1,1,1,5)
5 | 11 | scalar | uint | 0 | 32 | IntegerImage("",4,0,1,6)
6 | 7 | scalar | sint | 0 | 32 | IntegerImage("",4,1,1,7)
7 | 40 | scalar | uint | 0 | 64 | IntegerImage("",8,0,1,8)
8 | 39 | scalar | sint | 0 | 64 | IntegerImage("",8,1,1,9)
9 | 3 | complex | float | 0 | 32 | FFT of RealImage("",4,1,10)
10 | 2 | scalar | float | 0 | 32 | RealImage("",4,1,10)
11 | 12 | scalar | float | 0 | 64 | RealImage("",8,1,11)
12 | 3 | complex | float | 0 | 32 | ComplexImage("",8,1,12)
13 | 13 | complex | float | 0 | 64 | ComplexImage("",16,1,13)
14 | 15 | rgb | uint | 0 | 8 | RGBImage("",3,1,14)
15 | 23 | rgba | uint | 3 | 8 | RGBImage("",4,1,15)
16 | 17 | rgb | uint | 0 | 16 | RGBImage("",6,1,16)
17 | 24 | rgba | uint | 0 | 16 | RGBImage("",8,1,17)

<div class="datatable-end"></div>

Because this is being reported before saving the **Image Document**, there will be no thumbnail yet. Upon saving, a thumbnail will be generated (and named `Image Of RGBImage("",8,1,17)` in this case).

The `ConvertToPackedComplex()` seemed cannot actually create **Packed Complex Images** here. I also tried `RealFFT()`, but no luck either.

# Other sources of DM3/4 information
1. [*Digital Micrograph file format*](http://phyweb.physics.nus.edu.sg/~phybcb/info/dmformat/index.html), by Dr Chris Boothroyd. A must-read.

2. [An Igor Pro script](https://www.wavemetrics.com/comment/11439#comment-11439) to read DM3 file.

3. [`EMAN::DM4IO` Class Reference](https://blake.grid.bcm.edu/eman2/doxygen_html/classEMAN_1_1DM4IO.html), DM4 I/O written in C++.

4. [`DM3_Reader` plugin](https://imagej.nih.gov/ij/plugins/DM3_Reader.html) for ImageJ.

5. [`ncempy.io.dm`](https://openncem.readthedocs.io/en/latest/ncempy.io.html#module-ncempy.io.dm), the DM3/4 I/O module of openNCEM's python package.

[1]: http://phyweb.physics.nus.edu.sg/~phybcb/info/dmformat/index.html "Dr Chris Boothroyd's detailed explanations"
[2]: https://www.wavemetrics.com/comment/11439#comment-11439 "An Igor Pro script to read DM3 file"
[3]: https://blake.grid.bcm.edu/eman2/doxygen_html/classEMAN_1_1DM4IO.html "EMAN::DM4IO, C++ DM4 I/O"
[4]: https://imagej.nih.gov/ij/plugins/DM3_Reader.html "DM3_Reader plugin for ImageJ"
[5]: https://openncem.readthedocs.io/en/latest/ncempy.io.html#module-ncempy.io.dm "openNCEM's python DM3/4 I/O module"
